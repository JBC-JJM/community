# 项目环境

---



<img src="./assets/image-20230521192624528.png" alt="image-20230521192624528" style="zoom:50%;" />



**主要技术**

1. ssm：三层的框架

- spring：管理bean
- springMVC：处理请求
- mybatis：数据库

2. springBoot：开发简易

   整合了spring的内容或者第三方的内容（比如mybatis、光！）

3. 中间件：提高性能

- redis：将服务器查询数据库的结果放入内存中管理
- kafka：消息对列，发布评论之类的
- es：搜索引擎，没错就是类似浏览器的一种索引工具

4. spring的其他技术

- Spring Security: 权限管理，如登入、管理员和普通用户
- Spring Actuato：远程监控，方便维护的，本来应该是维护的活



## 初始pom

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.5.RELEASE</version>
    </parent>

    <groupId>com.nowcoder.community</groupId>
    <artifactId>community</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>community</name>
    <description>nowcoder community</description>

    <properties>
        <java.version>8</java.version>
    </properties>
    <dependencies>
<!--        aop-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
<!--        模板-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
<!--        服务器-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

<!--            springboot的开发者工具，右边会有个小框框-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

<!--        驱动-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.25</version>
        </dependency>

<!--        mybatis-spring-boot：有mybatis、mybatis-springBoot、jdbc-->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.0.1</version>
        </dependency>

<!--        导连接池的包，虽然springboot确实内嵌了HikariCP的版本，但是这个不导包居然也没事-->
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```



- 需要稍微注意一下编码是utf-8不然会爆炸

```yaml
server:
  port: 80  #端口号
  servlet:
    context-path: /community  #根url


spring:
  # ThymeleafProperties模板
  thymeleaf:
    cache: false
  #数据库连接,这里其实比较任意出错
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/community?characterEncoding=utf-8&useSSL=false&serverTimezone=Hongkong
    username: root
    password: 123456
    #光！：连接池
    type: com.zaxxer.hikari.HikariDataSource  #数据源的类型，这其实是连接池创建的了
    hikari:
      maximum-pool-size: 15 #连接对象上限# 最大连接数 默认10
      minimum-idle: 5 # 最小空闲连接数量
      idle-timeout: 30000 # 空闲连接存活最大时间 默认600000ms30000毫秒


#mybatis配置
mybatis:
  mapper-locations: classpath:mapper/*.xml  #扫描xml文件，由于xml和dao的接口文件不在同一报下
  type-aliases-package: com.nowcoder.community.entity #扫描实体类，简化包名
  configuration:
    useGeneratedKeys: true  #自动生成主键，大概是返回主键回填
    mapUnderscoreToCamelCase: true #返回值的映射，可以自动my_name转化为myName（底层就是mapResult）

#控制台输出日志的级别，可以看到sql语句（不过是更大的范围）
logging:
    level:
      com:
        nowcoder:
          community: debug
```















# 功能实现

## 分页功能实现

> 开发帖子，使用帖子表显示帖子
>
> - 实现分页查询
>   - sql编写
>   - 数据封装
> - 使用thymheaf模板编写

效果图如下

<img src="./assets/image-20230525220439836.png" alt="image-20230525220439836" style="zoom: 25%;" />



### E-R图部分结构

![image-20230525220328680](./assets/image-20230525220328680.png)





### 实体类

#### 帖子实体

```java
public class DiscussPost {
    private Integer id;
    private Integer userId;
    private String title;
    private String content;
    private Integer type;
    private Integer status;
    //可以使用string接收日期
    //https://blog.csdn.net/ITxiaofeixiang/article/details/117048760
    private Date createTime;
    private Integer commentCount;
    private Double score;
    //set/get/tostring
}
```

> 关于date数据封装和结构化//https://blog.csdn.net/ITxiaofeixiang/article/details/117048760



#### 用户实体

```java
public class User {
    private Integer id;
    private String username;
    private String password;
    private String salt;
    private String email;
    private Integer type;
    private Integer status;
    private String activationCode;
    private String headerUrl;
    private Date createTime;
}
```



#### 页面数据实体

```java
public class Page {
    //请求参数接收
    private int current = 1;  //当前页面
    private int limit = 10;   //一页面的数据量
    //响应参数
    private int rows;   //总数
    private String path;    //查询的url，当然其实rest风格编程不需要担心这个问题

    /**
     * 当前页的起始行,给sql分页查询使用
     *
     * @return
     */
    public int getOffset() {
        // current * limit - limit
        return (current - 1) * limit;
    }

    /**
     * 总页数,给前端显示页码用
     * @return
     */
    public int getTotal() {
        // rows / limit [+1]
        if (rows % limit == 0) {
            return rows / limit;
        } else {
            return rows / limit + 1;
        }
    }

    /**
     * 起始页码,虽然有点不合理，但是没有框架是这样的了，需要编写getFrom，从而模板可以使用page.from得到值
     * @return
     */
    public int getFrom() {
        int from = current - 2;
        return from < 1 ? 1 : from;
    }


    /**
     * 结束页码
     *
     * @return
     */
    public int getTo() {
        int to = current + 2;
        int total = getTotal();
        return to > total ? total : to;
    }

    public int getCurrent() {
        return current;
    }

    public void setCurrent(int current) {
        if (current >= 1) {
            this.current = current;
        } else System.out.println("current太小了");
        return;
    }

    /**
     * 一页的大小，给sql查询用
     *
     * @return
     */
    public int getLimit() {
        return limit;
    }

    public void setLimit(int limit) {
        if (1 <= limit && limit <= 100) {
            this.limit = limit;
        } else System.out.println("limit太小了或者太大了");
        return;
    }

    public int getRows() {
        return rows;
    }

    public void setRows(int rows) {
        if (rows >= 0) {
            this.rows = rows;
        }
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }
}

```

> 该实体类较为复杂，稍后再说



### dao

#### userMapper:用户表

```java
@Mapper
public interface UserMapper {
    User selectById(Integer id);

    User selectByName(String username);

    User selectByEmail(String email);

    int insertUser(User user);

    int updateStatus(Integer id, Integer status);

    int updateHeader(Integer id, String headerUrl);

    int updatePassword(Integer id, String password);
}
```



#### discussPostMapper：帖子表

```java
@Mapper
public interface DiscussPostMapper {
//    查询所有帖子
    //使用了动态sql，发现没有Param，当个参数居然找不到
    List<DiscussPost> selectAll(@Param("userId") Integer userId);
//    查询一页数据，userId默认为空，支持查询某个用户的帖子
    List<DiscussPost> selectDiscussPosts(@Param("userId") Integer userId, @Param("offset") Integer offset, @Param("limit") Integer limit);
//    查询总的数量，userId默认为空，支持查询某个用户的帖子的
    int selectDiscussPostsRows(@Param("userId") Integer userId);
}
```



> 实现sql语句不在这里说了
>
> discussPostMapper的实现需要考虑
>
> - 是否拉黑
> - `selectDiscussPosts(userId:用户,offset：起始条,limit：限制);` 查询帖子
>   - userId：当为0或者空时表示查询所有人的帖子
>   - userId：有值时表示查询某个用户的帖子
>
> - `selectDiscussPostsRows；` 查询帖子数量，同理
>
> - 排序
>   - 置顶？
>   - 创建时间
>
> - 分页数据来源
>   - 起始条
>   - limit限制
>









service并没有干活：路过









### controller的查询封装做法

![image-20230525225503628](./assets/image-20230525225503628.png)

![image-20230525225512521](./assets/image-20230525225512521.png)



> 多余了什么呢
>
> - 数据封装不在service层
>   - 封装page，应该是 一页的数据+页数 应该在service完成，没有这样做是由于假如封装为了page对象，那么在使用Redis则需要使用序列化的操作对page对象转化，这需要额外的cpu性能，这部分内容详细看redis
> - 前端的需要额外的数据
>   - 前后端不分离的后果





```java
@Controller
public class HomeController {

    @Autowired
    private DiscussPostService postService;

    @Autowired
    private UserService userService;

    @GetMapping("/index")
    public String getIndexPage(Model model,Page page) {

        //总数量
        int rows = postService.discussPostsRows(0);
        page.setRows(rows);
        page.setPath("/index");

        //帖子列表+用户数据
        List<Map<String,Object>> discussPosts = new ArrayList();
        //帖子列表
        List<DiscussPost> postList = postService.discussPosts(0, page.getOffset(),page.getLimit());
        for (DiscussPost post : postList) {
            Integer userId = post.getUserId();  //根据userid找发表帖子的用户
            //用户数据
            User user = userService.selectById(userId);

            Map<String,Object> map = new HashMap();
            map.put("post", post);
            map.put("user", user);

            discussPosts.add(map);
        }

//在开发模板时：假如模板有错误，那么报错很难找到
        model.addAttribute("discussPosts", discussPosts);
        model.addAttribute("page",page);
        return "/index";
    }
```

> 需要注意的是在使用模板时
>
> ```java
>  @GetMapping("/index")
>     public String getIndexPage(Model model,Page page)
> ```
>
> - `model:` 参数本质时req的请求转发的参数对象
> - `page:`  是请求的数据封装，但是也是需要发送给模板使用的
>   - `@RequestParam` get的参数别名，这是请求普通参数的写法，不可以用在pojo上
>   - `@RequestBody`  json的参数别名，只可以使用post请求

```java
(@RequestParam Page page) 错误，page是pojo类型
(@RequestBody  Page page) 可以，但是要post请求
```

















### 模板问题

#### 1、 路径问题

![image-20230523112943807](./assets/image-20230523112943807.png)

#### 2、 参数接收问题

- `map:discussPosts` :  从数组get元素  `foreach,map=discussPosts.get(0)...`

- `map.user`:        从map get值       `map.get("user")`  
- `map.user.title`: 从对象get值 `(DiscussPost)map.get("post").getTitle` 

![image-20230523200253017](./assets/image-20230523200253017.png)

#### 3、 日期问题

‘yyyy-MM-dd HH:mm:ss’



















## 注册功能实现

### E-R图结构

<img src="./assets/image-20230528211845991.png" alt="image-20230528211845991" style="zoom:50%;" />







### 基本流程

<img src="./assets/image-20230528212713944.png" alt="image-20230528212713944" style="zoom:50%;" />

当然，假如使用了前后端分离，第一次请求就不会需要经过controller





### 第一次请求：页面请求



#### LoginController

```java
@Controller
public class LoginController{

    @GetMapping("/register")
    public String getRegisterPage(){
        return "/site/register";
    }

```



#### 注册模板(/site/register)

##### 基本更改

- <html>使用 thymleaf

  ```html
  <html lang="en" xmlns:th="http://www.thymeleaf.org">
  ```

- 静态文件使用th：src / th：href

  ```html
  <link rel="stylesheet" th:href="@{/css/global.css}" />
  <script th:src="@{/js/global.js}"></script>
  ```

- 访问路径要使用，不是访问html，这样访问模板是不允许的

  ```html
  <a class="nav-link" th:href="@{/register}">注册</a>
  ```





##### 复用其他模板的组件

- /index.html

```html
<header class="bg-dark sticky-top" th:fragment="header">
```

- /site/register.html

```html
<!-- TODO:头部,替换为index的header -->
<header class="bg-dark sticky-top" th:replace="index::header">
</header>
```





##### post请求

> 需要注意的是，假如模板由较大的更改，则必须要要将target清空，重启maven

```html
<form class="mt-5" method="post" th:action="@{/register}">
<input type="text" id="username" name="username" placeholder="请输入您的账号!" required>
</form>
```











### 第二次请求：注册请求

#### 配置域名

> 方便日后使用邮件访问，因为是要外部点击url访问域名的
>
> `http://localhost:8080/community`

```yaml
server:
  port: 8080  #端口号
  servlet:
    context-path: /community  #根url

#域名
community:
  path:
    domain: http://localhost:8080
```





#### service

> 业务层不仅要检验数据有效性，还要封装数据、发送激活码

![image-20230528225051404](./assets/image-20230528225051404.png)

>- 注册
>  - salt\password\激活码：由于需要加密密码使用了数据类CommunityUtil，[详细看下面](#测试一下2)
>  - headerUrl：头像，使用了牛客的头像
>- 发送激活码邮件（[详细看下面](#测试一下2)）
>  - 先使用模板渲染数据得到html
>  - 将html发送



需要注入的bean和value

```java
    //激活码邮件相关
    @Autowired
    private TemplateEngine templateEngine;

    @Autowired
    private MailClient mailClient;

    //激活码的url相关
    @Value("${community.path.domain}")
    private String domain;

    @Value("${server.servlet.context-path}")
    private String contextPath;
```





```java
   public Map<String, Object> register(User user) {

        Map<String, Object> map=new HashMap();
//1、 检验为空,这个本来应该是数据库的活，这里略
//2、 检验账号存在，这里略

//3、 注册：封装数据给前端(用户填的+业务改造)，调用dao
        String salt= CommunityUtil.generateUUID().substring(0,5);//截取0到4，不包括5
        String password=CommunityUtil.MD5(user.getPassword()+salt);
        String activationCode=CommunityUtil.generateUUID();
        String headerUrl = String.format("https://images.nowcoder.com/head/%dt.png", new Random().nextInt(1000));

        User newUser = new User(user.getUsername(), password, salt, user.getEmail(), 0, 0, activationCode, headerUrl, new Date());
        int count = userMapper.insertUser(newUser);


//4、 发送激活码邮件
        Context context = new Context();
        context.setVariable("email",newUser.getEmail());
        //激活的url(id+激活码)由activation控制
        String url = domain + contextPath + "/activation/" + newUser.getId() + "/" + newUser.getActivationCode();
        context.setVariable("url",url);
        //使用模板引擎渲染并返回html
        String message = templateEngine.process("/mail/activation.html", context);
        mailClient.sendMail(user.getEmail(),"牛客激活邮件",message);

        //sql查询结>0
        if (count>0){
            System.out.println(newUser);
            map.put("code","success");
            return map;
        }
        return null;
    }
```









#### controller

<img src="./assets/image-20230528233013780.png" alt="image-20230528233013780" style="zoom:60%;" />

```java
    @PostMapping("/register")
    public String register(Model model,User user){
        Map<String, Object> map = userService.register(user);
        if(map.get("code")=="success"){
            model.addAttribute("msg","注册成功，请激活");
            model.addAttribute("target","/index");
            return "/site/operate-result";
        }
        else {
            model.addAttribute("usernameMsg", map.get("usernameMsg"));
            model.addAttribute("passwordMsg", map.get("passwordMsg"));
            model.addAttribute("emailMsg", map.get("emailMsg"));
            return "/site/register";
        }
    }
```

> 待实现：本来需要数据封装返回到前端的，但是偷懒了







#### 模板



- /mail/activation.html：渲染邮件的模板

比较简单，略了



- /site/operate-result：注册成功的模板

也比简单，略略







### 第三次请求

> 前面我们已经完成了注册和发送邮件的功能，还差激活
>
> 目的就是将user(id).status=1 激活

<img src="./assets/image-20230528235009399.png" alt="image-20230528235009399" style="zoom:50%;" />



> 工具类[详细](#常量接口)

#### service



```java
    //激活
    public int activation(int userId,String code){
        User user = userMapper.selectById(userId);
        //判断激活码,需要注意的是不可以使用！=
        if(!user.getActivationCode().equals(code)){
            System.out.println(user.getActivationCode());
            System.out.println(code);
            return ACTIVATION_FAILURE;
        }
        //重复激活
        if( user.getStatus()==1){
            return ACTIVATION_REPEAT;
        }
        //激活他
        userMapper.updateStatus(userId,1);
        return ACTIVATION_SUCCESS;
    }
```



> 需要注意的是
>
> - `!user.getActivationCode().equals(code)`
>
>   - 使用user.getActivationCode()！=code 是不ok的，因为两者的地址不一致导致
>
>   - 说明了==不是一定安全的操作
>
>     - == 的作用：
>       　　基本类型：比较的就是值是否相同
>       　　引用类型：比较的就是地址值是否相同（堆内存地址），同一个new出来的对象，则他们的比较后的结果为true，否则比较后结果为false。
>
>     - equals 的作用:
>       　　引用类型：重写前比较的是地址值，重写后比一般是比较对象的属性。判断两个变量是否是对同一个对象的引用，地址值是指堆中的地址值







#### controller



```java
    
	//顺便写个login来访问login模板
	@GetMapping("/login")
    public String getLoginPage(){
        return "site/login";
    }

    @GetMapping("/activation/{userId}/{code}")
    public String activation( Model model, @PathVariable int userId, @PathVariable String code){
        int result = userService.activation(userId, code);
        if (result == ACTIVATION_SUCCESS) {
            model.addAttribute("msg", "激活成功,您的账号已经可以正常使用了!");
            model.addAttribute("target", "/login");
        } else if (result == ACTIVATION_REPEAT) {
            model.addAttribute("msg", "无效操作,该账号已经激活过了!");
            model.addAttribute("target", "/index");
        } else {
            model.addAttribute("msg", "激活失败,您提供的激活码不正确!");
            model.addAttribute("target", "/index");
        }
        //都是跳到激活页面
        return "/site/operate-result";
    }
```



> 需要注意的是
>
> - 想要访问一个模板就一定要编写对应的controller，直接跳转模板是没有动态数据的`"/login"`















# 调试

## 状态码

> 响应状态码主要分为几种
>
> - 2xx：成功
> - 3xx：重定向
> - 4xx：url找不到对应的controller
> - 5xx：服务器出错
>
> [官网](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/100)
>
> [状态码](D:\workplace\JavaWeb_Video\MyNote\Web核心\BS模型.md#2.4响应数据格式)
>
> [重定向原理详细原理](D:\workplace\JavaWeb_Video\MyNote\Web核心\sevlet_req_and_resp.md#Respones请求重定向)



### 重定向

这里简述一下重定向的原理

<img src="./assets/image-20230526203440818.png" alt="image-20230526203440818" style="zoom:40%;" />

> 程序都是讲究耦合的，删除的contoller去调用查询这是不好的，所以需要客户端重定向导查询



<img src="./assets/image-20230526203636393.png" alt="image-20230526203636393" style="zoom:40%;" />













## 断点调试

### 后端

![image-20230526204703631](./assets/image-20230526204703631.png)









### 前端



![image-20230526105040225](./assets/image-20230526105040225.png)









## 日记

### 测试

[官网](https://logback.qos.ch/manual/architecture.html)

> 级别：trace、debug、info、warn、error
>
> 显性的输出日记

```java
//首先声明是使用spring的测试类
@RunWith(SpringRunner.class)
@SpringBootTest
public class LoggerTests {

    //加载需要启动日记的类/包
   private Logger logger = LoggerFactory.getLogger(LoggerTests.class);

   @Test
    public void loggerOut(){
       System.out.println(logger.getName());	//是谁启动了日记
        
       logger.debug("debug log");				//输出对应的级别
       logger.info("info log");
       logger.warn("warn log");
       logger.error("error log");
   }
}
```

当然：会受到配置的影响，假如输出大于debug类型，则效果不同





### yaml配置

> 默认为info级别，默认输出导控制台
>
> 下面的级别，假如大于debug都会输出

![image-20230526111243124](./assets/image-20230526111243124.png)









### 配置文件

> 按照不同的级别输出为不同文件
>
> [官网](https://logback.qos.ch/manual/configuration.html)

![image-20230526194803201](./assets/image-20230526194803201.png)

> 优先：配置文件 > yaml













# 额外功能

## 邮箱发送

这里使用Spring Email

> - 邮箱设置
>   - 启用客户端SMTP服务
> - Spring Email
>   - 导入jar 包
>   - 邮箱参数配置
>   - 使用JavaMailSender 发送邮件
> - 模板引擎
>   - 使用Thymeleaf发送HTML 邮件



### 导包

>  学会使用maven仓库搜索并使用最实用的版本，[spring mail](https://mvnrepository.com/search?q=spring+mail)



```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
    <version>2.2.6.RELEASE</version>
</dependency>
```





### 配置

> springboot的配置要学会使用[文档](https://springdoc.cn/spring-boot/io.html#io.email)
>
> 网易云的smtp的host ： `smtp.163.com` [参考](https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2a5feb28b66796d3b)
>
> 网易云的password：[参考](https://blog.csdn.net/lx_nhs/article/details/83146206)

```yaml
spring:
  #mail的配置
  mail:
  	#域名端口
    host: smtp.163.com
    port: 465
	#账号
    username: jumpupchen@163.com
    #网易授权码
    password: GMPQHBEGANHCHBNF
    protocol: smtps	#加密协议
    properties:
      mail.smtp.ssl.enable: true	#ssl安全连接
```

​	



### JavaMailSender工具类

> 使用工具类方便日后重用
>
> helper[参考](https://docs.spring.io/spring-framework/docs/6.0.5/reference/html/integration.html#mail-javamail-mime)



- `/util/MailClient`

```java
//工具类大多都是可重用的bean
@Component
public class MailClient {

    //单独的配置该类的输出日志，比如平时其他类要是出错不会输出自定义的信息，
    // 这和aop不太一样，这里只是输出日志，没法处理
    private Logger logger = LoggerFactory.getLogger(MailClient.class);

    //使用springBoot的JavaMailSender，他会加载yaml的信息
    @Autowired
    private JavaMailSender mailSender;

    //该bean的主要方法
    public void sendMail(String to, String subject, String content) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message);
            helper.setFrom("jumpupchen@163.com");//谁发信息，需要和配置文件的一致
            helper.setTo(to);//发给谁
            helper.setSubject(subject);//标题
            helper.setText(content,true);//内容+开启html模式
            mailSender.send(helper.getMimeMessage());//发送
        } catch (MessagingException e) {
            logger.error("发送邮件失败"+e.getMessage()); //日志输出
        }
    }
}
```







### 测试一下1



- 测试类

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class MailTest {

    @Autowired
    private MailClient mailClient;

    @Autowired
//    注入模板引擎
    private TemplateEngine templateEngine;

    //发送文本试试
    @Test
    public void testMail(){     
        mailClient.sendMail("1811546213@qq.com","hello","xiaojian");
    }
    
    //发送html试试
    @Test
    public void testHtmlMail(){
        //传给模板的属性
        Context context = new Context();
        context.setVariable("msg","xiaojian");
        //使用模板引擎渲染并返回html
        String message = templateEngine.process("/mail/demo.html", context);
        System.out.println(message);

        mailClient.sendMail("1811546213@qq.com","html",message);
    }


}
```



- 模板`/mail/demo.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<i style="color: red">hello [[${msg}]]</i>
</body>
</html>
```











## commons-lang工具类

> 这个工具类本质可以像java.lang工具类一样使用，很方便

[工具类的使用](https://blog.csdn.net/wang_jing_jing/article/details/119182699)

### 导包

[导包](https://mvnrepository.com/artifact/org.apache.commons/commons-lang3/3.12.0)

```xml
<!--        commons-lang3工具-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.12.0</version>
        </dependency>
```



### 使用工具类

- 生成随机数：这里只是说明commons-lang的使用，[参考](https://blog.csdn.net/wang_jing_jing/article/details/119182699)
- 以下两个方法没有使用commons-lang
  - uuid生成：唯一的随机数，使用java原生的生成的数据原本为（`20971348-d91e-4b63-be2c-0d9d02aa1dab`）
  - MD5加密: 这里使用springBoot的整合的玩意

```java
public class CommunityUtil {
    
    public static String randomTest(){
//        生成指定长度的字母和数字组成的随机组合字符串
//        https://blog.csdn.net/wang_jing_jing/article/details/119182699
        return RandomStringUtils.randomAlphanumeric(32);
    }
    
    public static String generateUUID(){
        //java生成uuid的办法，将‘-’替换位”“ ，生成的是32位的16进制数
        return UUID.randomUUID().toString().replaceAll("-", "");
    }

    /**springBoot整合了md5
     * @param key: password+salt
     * @return
     */
    public static String MD5(String key){
        if (StringUtils.isBlank(key)) {
            return null;
        }
        return DigestUtils.md5DigestAsHex(key.getBytes());
    }
}
```



<img src="./assets/image-20230528221951590.png" alt="image-20230528221951590" style="zoom:50%;" />

> 需要注意的是到时加入到数据库就不可以当当是password了
>
> - salt
> - PASSWORD

### 测试一下2

```java
//salt和md5
String salt= CommunityUtil.generateUUID().substring(0,5);//截取0到4，不包括5
String password=CommunityUtil.MD5(user.getPassword()+salt);

//32位激活码，因为本质就是数据数就行
String activationCode=CommunityUtil.generateUUID();
```











## 常量接口

```java

public interface CommunityConstant {
    /**
     * 激活成功
     */
    static final int ACTIVATION_SUCCESS = 0;

    /**
     * 重复激活
     */
    static final int ACTIVATION_REPEAT = 1;

    /**
     * 激活失败
     */
    static final int ACTIVATION_FAILURE = 2;
}

```



return可以直接使用

```java
return ACTIVATION_FAILURE;
```

其他地方使用就要 `implements CommunityConstant`

```java
result == ACTIVATION_SUCCESS
```



# date

# 常量接口

