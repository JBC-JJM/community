# 项目环境

---



<img src="./assets/image-20230521192624528.png" alt="image-20230521192624528" style="zoom:50%;" />



**主要技术**

1. ssm：三层的框架

- spring：管理bean
- springMVC：处理请求
- mybatis：数据库

2. springBoot：开发简易

   整合了spring的内容或者第三方的内容（比如mybatis、光！）

3. 中间件：提高性能

- redis：将服务器查询数据库的结果放入内存中管理
- kafka：消息对列，发布评论之类的
- es：搜索引擎，没错就是类似浏览器的一种索引工具

4. spring的其他技术

- Spring Security: 权限管理，如登入、管理员和普通用户
- Spring Actuato：远程监控，方便维护的，本来应该是维护的活



## 初始pom

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.5.RELEASE</version>
    </parent>

    <groupId>com.nowcoder.community</groupId>
    <artifactId>community</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>community</name>
    <description>nowcoder community</description>

    <properties>
        <java.version>8</java.version>
    </properties>
    <dependencies>
<!--        aop-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
<!--        模板-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
<!--        服务器-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

<!--            springboot的开发者工具，右边会有个小框框-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

<!--        驱动-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.25</version>
        </dependency>

<!--        mybatis-spring-boot：有mybatis、mybatis-springBoot、jdbc-->
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.0.1</version>
        </dependency>

<!--        导连接池的包，虽然springboot确实内嵌了HikariCP的版本，但是这个不导包居然也没事-->
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```



- 需要稍微注意一下编码是utf-8不然会爆炸

```yaml
server:
  port: 80  #端口号
  servlet:
    context-path: /community  #根url


spring:
  # ThymeleafProperties模板
  thymeleaf:
    cache: false
  #数据库连接,这里其实比较任意出错
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/community?characterEncoding=utf-8&useSSL=false&serverTimezone=Hongkong
    username: root
    password: 123456
    #光！：连接池
    type: com.zaxxer.hikari.HikariDataSource  #数据源的类型，这其实是连接池创建的了
    hikari:
      maximum-pool-size: 15 #连接对象上限# 最大连接数 默认10
      minimum-idle: 5 # 最小空闲连接数量
      idle-timeout: 30000 # 空闲连接存活最大时间 默认600000ms30000毫秒


#mybatis配置
mybatis:
  mapper-locations: classpath:mapper/*.xml  #扫描xml文件，由于xml和dao的接口文件不在同一报下
  type-aliases-package: com.nowcoder.community.entity #扫描实体类，简化包名
  configuration:
    useGeneratedKeys: true  #自动生成主键，大概是返回主键回填
    mapUnderscoreToCamelCase: true #返回值的映射，可以自动my_name转化为myName（底层就是mapResult）

#控制台输出日志的级别，可以看到sql语句（不过是更大的范围）
logging:
    level:
      com:
        nowcoder:
          community: debug
```















# 功能实现

## 分页功能实现

> 开发帖子，使用帖子表显示帖子
>
> - 实现分页查询
>   - sql编写
>   - 数据封装
> - 使用thymheaf模板编写

效果图如下

<img src="./assets/image-20230525220439836.png" alt="image-20230525220439836" style="zoom: 25%;" />



### E-R图部分结构

![image-20230525220328680](./assets/image-20230525220328680.png)





### 实体类

#### 帖子实体

```java
public class DiscussPost {
    private Integer id;
    private Integer userId;
    private String title;
    private String content;
    private Integer type;
    private Integer status;
    //可以使用string接收日期
    //https://blog.csdn.net/ITxiaofeixiang/article/details/117048760
    private Date createTime;
    private Integer commentCount;
    private Double score;
    //set/get/tostring
}
```

> 关于date数据封装和结构化//https://blog.csdn.net/ITxiaofeixiang/article/details/117048760



#### 用户实体

```java
public class User {
    private Integer id;
    private String username;
    private String password;
    private String salt;
    private String email;
    private Integer type;
    private Integer status;
    private String activationCode;
    private String headerUrl;
    private Date createTime;
}
```



#### 页面数据实体

```java
public class Page {
    //请求参数接收
    private int current = 1;  //当前页面
    private int limit = 10;   //一页面的数据量
    //响应参数
    private int rows;   //总数
    private String path;    //查询的url，当然其实rest风格编程不需要担心这个问题

    /**
     * 当前页的起始行,给sql分页查询使用
     *
     * @return
     */
    public int getOffset() {
        // current * limit - limit
        return (current - 1) * limit;
    }

    /**
     * 总页数,给前端显示页码用
     * @return
     */
    public int getTotal() {
        // rows / limit [+1]
        if (rows % limit == 0) {
            return rows / limit;
        } else {
            return rows / limit + 1;
        }
    }

    /**
     * 起始页码,虽然有点不合理，但是没有框架是这样的了，需要编写getFrom，从而模板可以使用page.from得到值
     * @return
     */
    public int getFrom() {
        int from = current - 2;
        return from < 1 ? 1 : from;
    }


    /**
     * 结束页码
     *
     * @return
     */
    public int getTo() {
        int to = current + 2;
        int total = getTotal();
        return to > total ? total : to;
    }

    public int getCurrent() {
        return current;
    }

    public void setCurrent(int current) {
        if (current >= 1) {
            this.current = current;
        } else System.out.println("current太小了");
        return;
    }

    /**
     * 一页的大小，给sql查询用
     *
     * @return
     */
    public int getLimit() {
        return limit;
    }

    public void setLimit(int limit) {
        if (1 <= limit && limit <= 100) {
            this.limit = limit;
        } else System.out.println("limit太小了或者太大了");
        return;
    }

    public int getRows() {
        return rows;
    }

    public void setRows(int rows) {
        if (rows >= 0) {
            this.rows = rows;
        }
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }
}

```

> 该实体类较为复杂，稍后再说



### dao

#### userMapper:用户表

```java
@Mapper
public interface UserMapper {
    User selectById(Integer id);

    User selectByName(String username);

    User selectByEmail(String email);

    int insertUser(User user);

    int updateStatus(Integer id, Integer status);

    int updateHeader(Integer id, String headerUrl);

    int updatePassword(Integer id, String password);
}
```



#### discussPostMapper：帖子表

```java
@Mapper
public interface DiscussPostMapper {
//    查询所有帖子
    //使用了动态sql，发现没有Param，当个参数居然找不到
    List<DiscussPost> selectAll(@Param("userId") Integer userId);
//    查询一页数据，userId默认为空，支持查询某个用户的帖子
    List<DiscussPost> selectDiscussPosts(@Param("userId") Integer userId, @Param("offset") Integer offset, @Param("limit") Integer limit);
//    查询总的数量，userId默认为空，支持查询某个用户的帖子的
    int selectDiscussPostsRows(@Param("userId") Integer userId);
}
```



> 实现sql语句不在这里说了
>
> discussPostMapper的实现需要考虑
>
> - 是否拉黑
> - `selectDiscussPosts(userId:用户,offset：起始条,limit：限制);` 查询帖子
>   - userId：当为0或者空时表示查询所有人的帖子
>   - userId：有值时表示查询某个用户的帖子
>
> - `selectDiscussPostsRows；` 查询帖子数量，同理
>
> - 排序
>   - 置顶？
>   - 创建时间
>
> - 分页数据来源
>   - 起始条
>   - limit限制
>









service并没有干活：路过









### controller的查询封装做法

![image-20230525225503628](./assets/image-20230525225503628.png)

![image-20230525225512521](./assets/image-20230525225512521.png)



> 多余了什么呢
>
> - 数据封装不在service层
>   - 封装page，应该是 一页的数据+页数 应该在service完成，没有这样做是由于假如封装为了page对象，那么在使用Redis则需要使用序列化的操作对page对象转化，这需要额外的cpu性能，这部分内容详细看redis
> - 前端的需要额外的数据
>   - 前后端不分离的后果





```java
@Controller
public class HomeController {

    @Autowired
    private DiscussPostService postService;

    @Autowired
    private UserService userService;

    @GetMapping("/index")
    public String getIndexPage(Model model,Page page) {

        //总数量
        int rows = postService.discussPostsRows(0);
        page.setRows(rows);
        page.setPath("/index");

        //帖子列表+用户数据
        List<Map<String,Object>> discussPosts = new ArrayList();
        //帖子列表
        List<DiscussPost> postList = postService.discussPosts(0, page.getOffset(),page.getLimit());
        for (DiscussPost post : postList) {
            Integer userId = post.getUserId();  //根据userid找发表帖子的用户
            //用户数据
            User user = userService.selectById(userId);

            Map<String,Object> map = new HashMap();
            map.put("post", post);
            map.put("user", user);

            discussPosts.add(map);
        }

//在开发模板时：假如模板有错误，那么报错很难找到
        model.addAttribute("discussPosts", discussPosts);
        model.addAttribute("page",page);
        return "/index";
    }
```

> 需要注意的是在使用模板时
>
> ```java
>  @GetMapping("/index")
>     public String getIndexPage(Model model,Page page)
> ```
>
> - `model:` 参数本质时req的请求转发的参数对象
> - `page:`  是请求的数据封装，但是也是需要发送给模板使用的
>   - `@RequestParam` get的参数别名，这是请求普通参数的写法，不可以用在pojo上
>   - `@RequestBody`  json的参数别名，只可以使用post请求

```java
(@RequestParam Page page) 错误，page是pojo类型
(@RequestBody  Page page) 可以，但是要post请求
```

















### 模板问题

#### 1、 路径问题

![image-20230523112943807](./assets/image-20230523112943807.png)

#### 2、 参数接收问题

- `map:discussPosts` :  从数组get元素  `foreach,map=discussPosts.get(0)...`

- `map.user`:        从map get值       `map.get("user")`  
- `map.user.title`: 从对象get值 `(DiscussPost)map.get("post").getTitle` 

![image-20230523200253017](./assets/image-20230523200253017.png)

#### 3、 日期问题

‘yyyy-MM-dd HH:mm:ss’



















## 注册功能实现

### E-R图结构

<img src="./assets/image-20230528211845991.png" alt="image-20230528211845991" style="zoom:50%;" />







### 基本流程

<img src="./assets/image-20230528212713944.png" alt="image-20230528212713944" style="zoom:50%;" />

当然，假如使用了前后端分离，第一次请求就不会需要经过controller





### 第一次请求：页面请求



#### LoginController

```java
@Controller
public class LoginController{

    @GetMapping("/register")
    public String getRegisterPage(){
        return "/site/register";
    }

```



#### 注册模板(/site/register)

##### 基本更改

- <html>使用 thymleaf

  ```html
  <html lang="en" xmlns:th="http://www.thymeleaf.org">
  ```

- 静态文件使用th：src / th：href

  ```html
  <link rel="stylesheet" th:href="@{/css/global.css}" />
  <script th:src="@{/js/global.js}"></script>
  ```

- 访问路径要使用，不是访问html，这样访问模板是不允许的

  ```html
  <a class="nav-link" th:href="@{/register}">注册</a>
  ```





##### 复用其他模板的组件

- /index.html

```html
<header class="bg-dark sticky-top" th:fragment="header">
```

- /site/register.html

```html
<!-- TODO:头部,替换为index的header -->
<header class="bg-dark sticky-top" th:replace="index::header">
</header>
```





##### post请求

> 需要注意的是，假如模板由较大的更改，则必须要要将target清空，重启maven

```html
<form class="mt-5" method="post" th:action="@{/register}">
<input type="text" id="username" name="username" placeholder="请输入您的账号!" required>
</form>
```











### 第二次请求：注册请求

#### 配置域名

> 方便日后使用邮件访问，因为是要外部点击url访问域名的
>
> `http://localhost:8080/community`

```yaml
server:
  port: 8080  #端口号
  servlet:
    context-path: /community  #根url

#域名
community:
  path:
    domain: http://localhost:8080
```





#### service

> 业务层不仅要检验数据有效性，还要封装数据、发送激活码

![image-20230528225051404](./assets/image-20230528225051404.png)

>- 注册
>  - salt\password\激活码：由于需要加密密码使用了数据类CommunityUtil，[详细看下面](#测试一下2)
>  - headerUrl：头像，使用了牛客的头像
>- 发送激活码邮件（[详细看下面](#测试一下2)）
>  - 先使用模板渲染数据得到html
>  - 将html发送



需要注入的bean和value

```java
    //激活码邮件相关
    @Autowired
    private TemplateEngine templateEngine;

    @Autowired
    private MailClient mailClient;

    //激活码的url相关
    @Value("${community.path.domain}")
    private String domain;

    @Value("${server.servlet.context-path}")
    private String contextPath;
```





```java
   public Map<String, Object> register(User user) {

        Map<String, Object> map=new HashMap();
//1、 检验为空,这个本来应该是数据库的活，这里略
//2、 检验账号存在，这里略

//3、 注册：封装数据给前端(用户填的+业务改造)，调用dao
        String salt= CommunityUtil.generateUUID().substring(0,5);//截取0到4，不包括5
        String password=CommunityUtil.MD5(user.getPassword()+salt);
        String activationCode=CommunityUtil.generateUUID();
        String headerUrl = String.format("https://images.nowcoder.com/head/%dt.png", new Random().nextInt(1000));

        User newUser = new User(user.getUsername(), password, salt, user.getEmail(), 0, 0, activationCode, headerUrl, new Date());
        int count = userMapper.insertUser(newUser);


//4、 发送激活码邮件
        Context context = new Context();
        context.setVariable("email",newUser.getEmail());
        //激活的url(id+激活码)由activation控制
        String url = domain + contextPath + "/activation/" + newUser.getId() + "/" + newUser.getActivationCode();
        context.setVariable("url",url);
        //使用模板引擎渲染并返回html
        String message = templateEngine.process("/mail/activation.html", context);
        mailClient.sendMail(user.getEmail(),"牛客激活邮件",message);

        //sql查询结>0
        if (count>0){
            System.out.println(newUser);
            map.put("code","success");
            return map;
        }
        return null;
    }
```









#### controller

<img src="./assets/image-20230528233013780.png" alt="image-20230528233013780" style="zoom:60%;" />

```java
    @PostMapping("/register")
    public String register(Model model,User user){
        Map<String, Object> map = userService.register(user);
        if(map.get("code")=="success"){
            model.addAttribute("msg","注册成功，请激活");
            model.addAttribute("target","/index");
            return "/site/operate-result";
        }
        else {
            model.addAttribute("usernameMsg", map.get("usernameMsg"));
            model.addAttribute("passwordMsg", map.get("passwordMsg"));
            model.addAttribute("emailMsg", map.get("emailMsg"));
            return "/site/register";
        }
    }
```

> 待实现：本来需要数据封装返回到前端的，但是偷懒了







#### 模板



- /mail/activation.html：渲染邮件的模板

比较简单，略了



- /site/operate-result：注册成功的模板

也比简单，略略







### 第三次请求

> 前面我们已经完成了注册和发送邮件的功能，还差激活
>
> 目的就是将user(id).status=1 激活

<img src="./assets/image-20230528235009399.png" alt="image-20230528235009399" style="zoom:50%;" />



> 工具类[详细](#常量接口)

#### service



```java
    //激活
    public int activation(int userId,String code){
        User user = userMapper.selectById(userId);
        //判断激活码,需要注意的是不可以使用！=
        if(!user.getActivationCode().equals(code)){
            System.out.println(user.getActivationCode());
            System.out.println(code);
            return ACTIVATION_FAILURE;
        }
        //重复激活
        if( user.getStatus()==1){
            return ACTIVATION_REPEAT;
        }
        //激活他
        userMapper.updateStatus(userId,1);
        return ACTIVATION_SUCCESS;
    }
```



> 需要注意的是
>
> - `!user.getActivationCode().equals(code)`
>
>   - 使用user.getActivationCode()！=code 是不ok的，因为两者的地址不一致导致
>
>   - 说明了==不是一定安全的操作
>
>     - == 的作用：
>       　　基本类型：比较的就是值是否相同
>         　　引用类型：比较的就是地址值是否相同（堆内存地址），同一个new出来的对象，则他们的比较后的结果为true，否则比较后结果为false。
>
>     - equals 的作用:
>       　　引用类型：重写前比较的是地址值，重写后比一般是比较对象的属性。判断两个变量是否是对同一个对象的引用，地址值是指堆中的地址值







#### controller



```java
    
	//顺便写个login来访问login模板
	@GetMapping("/login")
    public String getLoginPage(){
        return "site/login";
    }

    @GetMapping("/activation/{userId}/{code}")
    public String activation( Model model, @PathVariable int userId, @PathVariable String code){
        int result = userService.activation(userId, code);
        if (result == ACTIVATION_SUCCESS) {
            model.addAttribute("msg", "激活成功,您的账号已经可以正常使用了!");
            model.addAttribute("target", "/login");
        } else if (result == ACTIVATION_REPEAT) {
            model.addAttribute("msg", "无效操作,该账号已经激活过了!");
            model.addAttribute("target", "/index");
        } else {
            model.addAttribute("msg", "激活失败,您提供的激活码不正确!");
            model.addAttribute("target", "/index");
        }
        //都是跳到激活页面
        return "/site/operate-result";
    }
```



> 需要注意的是
>
> - 想要访问一个模板就一定要编写对应的controller，直接跳转模板是没有动态数据的`"/login"`











## 登入功能实现



### 验证码

![image-20230529223551846](./assets/image-20230529223551846.png)

#### contorller

LoginContorller

```java
    @Autowired
    private DefaultKaptcha kaptcha;

    private Logger logger = LoggerFactory.getLogger(LoginController.class);

    @GetMapping("/login")
    public String getLoginPage() {
        return "site/login";
    }

    @GetMapping("/kaptcha-image")
    public void getKaptchaImage(HttpSession session, HttpServletResponse response) throws IOException {
        //验证码、图片流
        String text = kaptcha.createText();
        BufferedImage img = kaptcha.createImage(text);

        //将验证码放到session：安全
        session.setAttribute("verifycode", text);

        ServletOutputStream out = null;
        try {
            // 向页面输出验证码: 将img字节码拷贝到out以便响应为图片
            out = response.getOutputStream();
            ImageIO.write(img, "jpg", out);
        } catch (Exception e) {
            logger.error("LoginController获取验证码图片失败");
        }finally {
            // 清空缓存区
            out.flush();
            out.close();
        }
    }

```

> DefaultKaptcha工具类[详细看](#验证码工具)

> 注意：session、response使用的是springBoot自动注入
>
> 注入bean的方式：
>
> - 自动注入：@bean的参数和springBoot的个别如session，response，request这些会
> - @Autowired：其它的bean是要自己搞得
>
> springBoot是由于dispatcch的实现req(session/cookie)和resp的自动注入，详细看req和resp





#### 模板

`login.html`

![image-20230529114800727](./assets/image-20230529114800727.png)

- js代码

```js
	function refresh_kaptcha(){
		let path=CONTEXT_PATH+"/kaptcha-image?random="+Math.random();	//访问路径
		$("#kaptcha").attr("src",path);
	}
```

> 欺骗浏览器发起请求`?random="+Math.random()`：注意是参数



`global.js`

![image-20230529114803605](./assets/image-20230529114803605.png)













### 登入逻辑

#### E-R图结构

<img src="./assets/image-20230531215032344.png" alt="image-20230531215032344" style="zoom:50%;" />

#### 基本流程



![image-20230531224302954](./assets/image-20230531224302954.png)



> 有点心累偷懒了





#### 实体类

##### LoginTicket

> 对应数据库的数据

```java
    private Integer id;
    private Integer userId;
    private String ticket;
    private Integer status;
    /**
     * 时效：当前时间戳+有效时长
     */
    private Date expired;
```



##### UserForm

> 前端数据调用的一个封装,就是表单提交的数据

```java
    private String username;
    private String password;
    private String verifycode;
    private Boolean rememberme;
    private Long expiredSecond;	//最长有效时长：时间戳，不是long问题应该也不大
```







#### Mapper

```java
@Mapper
public interface LoginTicketMapper {
//插入
    int insertLoginTicket(LoginTicket loginTicket);
//根据ticket查询
    LoginTicket selectByTicket(String ticket);
//将ticket的有效性更改
    int updateStatusTicket(@Param("ticket") String ticket, @Param("status") int status);
}

```





#### service

>  逻辑上写在这里也是合理的`UserServiceImpl.java`

```java
    @Autowired
    private LoginTicketMapper loginTicketMapper;

    /**
     * 其中时长是时间戳，以秒为单位
     * @param userForm 将前端传来的数据封装一下：名称+密码+时长+记住我
     * @return
     */
    @Override
    public Map<String, Object> login(UserForm userForm) {
        Map<String, Object> map = new HashMap<>();
        //1、 判空
        if (StringUtils.isBlank(userForm.getUsername())) {
            map.put("usernameMsg", "用户名不可为空");
            return map;
        }
        if (StringUtils.isBlank(userForm.getPassword())) {
            map.put("passwordMsg", "密码不能为空!");
            return map;
        }

        //2、 验证 存在\激活？
        User user = userMapper.selectByName(userForm.getUsername());
        if (user == null || user.getStatus() == 0) {
            map.put("usernameMsg", "账号不存在或者没激活");
            return map;
        }
        String password=CommunityUtil.MD5(userForm.getPassword()+user.getSalt());
        if (!user.getPassword().equals(password)) {
            map.put("passwordMsg", "密码错误!");
            return map;
        }

        //3、 干活：生成登入凭证并insert
        //凭证
        String ticket = CommunityUtil.generateUUID();
        //有效时长，注意时间戳以毫秒为单位
        Date date = new Date(System.currentTimeMillis() + userForm.getExpiredSecond()*1000);
        //封装为实体搞到dao
        LoginTicket loginTicket = new LoginTicket(user.getId(), ticket, 0, date);
        loginTicketMapper.insertLoginTicket(loginTicket);
        
        //4、 没错就返回ticket到控制器
        map.put("ticket",ticket);
        return map;
    }
```

> - 判空
>   - 一般引用对象：使用`!=null` ， 这也是为什么使用Integer不使用int的原因，可以偷懒
>   - String判空 `StringUtils.isBlank()` 或 `!=null && !=“ ”`
>   
> - 相等
>   - 引用类型：判相等
>   
>     ```java
>     Integer a=new Integer(12);  Integer b=new Integer(12); 
>     b!=a //因为内存空间不同
>     ```
>   
>   - String：判相等  `"abc".equals()` , ==不要使用`==`== 除非你想判断内存空间也一致
>   
> - 时间戳
>   - 方便计算时间运算：[详细参考](D:\workplace\JavaWeb_Video\MyNote\JavaBase\java乱套.md#时间戳)







#### Contorller

 `LoginController.java`

```java
   //项目根目录
	@Value("${server.servlet.context-path}")
    private String contextPath;


	//防止login页面报错，详细看springBoot的杂谈
	@GetMapping("/login")
    public String getLoginPage(Model model) {
        UserForm userForm = new UserForm();
        model.addAttribute("userForm",userForm);
        return "site/login";
    }


   @PostMapping("/login")
    public String login(Model model,
                        UserForm userForm,	//用户发来的信息
                        HttpSession session,
                        HttpServletResponse response) {
		//之前请求set到seesion的验证码
        String verifyCode = (String) session.getAttribute("verifycode");

        //1、 判空和比较验证码
        if (StringUtils.isBlank(verifyCode) || StringUtils.isBlank(userForm.getVerifycode()) || !verifyCode.equalsIgnoreCase(userForm.getVerifycode())) {
            model.addAttribute("codeMsg", "验证码不正确!");
            return "/site/login";
        }

        //2、 是否勾选记住我
        int seconds = userForm.getRememberme() ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;
        userForm.setExpiredSecond((long) seconds);

        //3、 调用service插入，service成功操作就是有ticket凭证
        Map<String, Object> map = userService.login(userForm);
        if (map.containsKey("ticket")) {
            //将凭证返回客户端
            Cookie cookie = new Cookie("ticket", (String) map.get("ticket"));
            cookie.setPath(contextPath);
            cookie.setMaxAge(seconds);
            response.addCookie(cookie);

            //使用重定向，发起get index 的请求，合理
            return "redirect:/index";
        }
        //失败就跳回登入界面
        model.addAttribute("usernameMsg", map.get("usernameMsg"));
        model.addAttribute("passwordMsg", map.get("passwordMsg"));
        //数据回填
        model.addAttribute("userForm",userForm);
        return "/site/login";
    }
```

> - 将跳到login的页面的控制器都加上`userForm`变量
> - 判断验证码
>   - 无视大小写`verifyCode.equalsIgnoreCase(userForm.getVerifycode())`
> - 记住我的常量时长
>   - REMEMBER_EXPIRED_SECONDS：DEFAULT_EXPIRED_SECONDS都是时间戳形式方便运算





#### 模板

要改的就是login和index而已，没啥要注意的

> 注意的是将跳到login的页面的控制器都加上`userForm`变量，这个，还是看srpingboot的杂谈











### 退出登入

> 有手就行



#### service

> 就是将表的ticket无效化就行

```java
    @Override
    public void logout(String ticket) {
        loginTicketMapper.updateStatusTicket(ticket,1);
    }
```



#### Contorller

 `LoginController.java`

> 登入之后请求都会携带ticket登入凭证，获取到他就可以无效化了

```java
    @GetMapping("logout")
    public String logout(@CookieValue("ticket") String ticket){
        userService.logout(ticket);
        //重定向：重写发起请求
        return "redirect:/login";
    }
```













### 显示用户信息

> 虽然不应该单独的写，但是有关拦截器



![image-20230531230715857](./assets/image-20230531230715857.png)



#### 拦截器

```java
@Component
public class LoginTicketInterceptor implements HandlerInterceptor {

    @Autowired
    private UserService userService;

    @Autowired
    private HostHolder hostHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //从cookie中获取得ticket，根据ticket查询用户的数据
        String ticket = CookieUtil.getValue(request, "ticket");
        //判空
        if (ticket != null) {
            LoginTicket loginTicket = userService.findLoginTicket(ticket);
            //有效性、时效
            //date类型比较 https://blog.csdn.net/chenpp666/article/details/125172674
            if (loginTicket != null && loginTicket.getStatus() == 0 && loginTicket.getExpired().after(new Date())) {
                User user = userService.selectById(loginTicket.getUserId());
                //将用户数据放到ThreadLocal
                hostHolder.setUser(user);
            }
        }
        return true;
    }

    //模板从ThreadLocal获取user数据
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        if (hostHolder.getUser() == null || modelAndView == null) {
            return;
        }
        modelAndView.addObject("loginUser", hostHolder.getUser());
    }

    //将ThreadLocal的数据清空
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        hostHolder.clean();
    }
}
```

> - 拦截器
>   - 参考springMvc的ssm项目
> - getCookie工具：CookieUtil 看下面
> - user线程绑定：HostHolder 看下面



#### 配置类

```java
@Configuration
public class WebMvcSupport implements WebMvcConfigurer {

    @Autowired
    private LoginTicketInterceptor interceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(interceptor)
                .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");
    }
}
```



















## 上传图片

> 本质上，上传图片应该是用户将本地的图片文件通过网络请求到服务器，服务器在将图片放到磁盘，读取时按照服务器的磁盘路径读取图片在返回到前端，这个过程并不需要使用dao存储啦，是直接存放到服务器磁盘



### 基本流程

![image-20230608225231100](./assets/image-20230608225231100.png)

首先配置服务器存放图片的路径

```yaml
community:
  path:
    upload: d:/workplace/JavaWeb_Video/Project/community/other_data/upload
```



### 上传图片



#### service

> 表中更新图片路径为`服务器的web路径`

```java
/**
 *
 * @param id
 * @param headerUrl ：web地址 = 域名（端口）+项目目录+user/header+文件名
 * @return
 */
boolean updateHeader(int id,String headerUrl);
```





#### contorller

 `UserController.java`

```java
//上传图片
@LoginRequired
@PostMapping("/upload")
public String uploadImage(MultipartFile headerImage, Model model) {
    if (headerImage == null) {
        model.addAttribute("error", "您还没有选择图片!");
        return "/site/setting";
    }
    //1、保存图片文件到本地
    //1.1 获取类型
    String fileName = headerImage.getOriginalFilename();
    String imageType = fileName.substring(fileName.lastIndexOf("."));
    if (StringUtils.isBlank(imageType)) {
        model.addAttribute("error", "文件的格式不正确!");
        return "/site/setting";
    }

    //1.2 新建本地图片文件：输出流，，，，输入流就是MultipartFile
    String imageName = CommunityUtil.generateUUID() + "." + imageType;
    File file = new File(uploadPath + "/" + imageName);
    //1.3 流输出：使用MultipartFile的流输出
    try {
        headerImage.transferTo(file);
    } catch (IOException e) {
        logger.error("上传文件失败: " + e.getMessage());
        throw new RuntimeException("上传文件失败,服务器发生异常!", e);
    }

    //2、更新用户头像路径
    User user = hostHolder.getUser();
    //域名（端口）+项目目录+user/header+文件名
    String headerUrl = domain + contextPath + "/user/header/" + imageName;
    userService.updateHeader(user.getId(), headerUrl);
    return "redirect:/index";
}
```



> * @param headerImage : 图片文件接收,不要犯请求参数名称不对应的错误,为了使用什么nb的框架参数在http参数后名称不一致大概都会有错，即使封装了
>   * 需要注意的是这样默认传输的图片不可以大于1m,参考 https://blog.csdn.net/weixin_62883794/article/details/130746018
> * 图片上传流





#### 模板

>  `enctype="multipart/form-data"` ：才可以传输图片这种复杂格式

```html
<form class="mt-5" method="post" enctype="multipart/form-data" th:action="@{/user/upload}">
.....
    <div class="form-group row mt-4">
        <div class="col-sm-2"></div>
        <div class="col-sm-10 text-center">
            <button type="submit" class="btn btn-info text-white form-control">立即上传</button>
        </div>
    </div>
</form>
```





### 读取图片



```java
 //图片访问路径
    @GetMapping("/header/{fileName}")
    public void getHeaderImage(@PathVariable String fileName, HttpServletResponse response) {
        // 服务器存放路径
            fileName = uploadPath + "/" + fileName;
        // 文件类型
        String suffix = fileName.substring(fileName.lastIndexOf(".")+1);
        // 响应图片
        response.setContentType("image/" + suffix);
        //自动关闭tyr-catch-resources 资源
        try (
                FileInputStream fis = new FileInputStream(fileName);
                OutputStream os = response.getOutputStream();
        ) {
            //输入流(BufferedImage)、类型、输出流
            ImageIO.write(ImageIO.read(fis),suffix,os);
        } catch (IOException e) {
            logger.error("读取头像失败: " + e.getMessage());
        }
    }
```

> 1. 自动关闭tyr-catch-resources 资源
> 2. 图片响应流















## 修改密码

> 有手就行，这里详细探讨了post表单请求的类型，关于为什么模板表单请求不能使用@rebody接收的问题
>
> [看这里](D:\workplace\JavaWeb_Video\MyNote\Web核心\BS模型.md#post请求数据类型)
>
> [想快看这里：](D:\workplace\JavaWeb_Video\MyNote\Web核心\BS模型.md一般只要关心)



### service

```java
    /**
     * 更新密码，密码都是没加密的就行
     * @param id
     * @param password
     * @param oldPassword
     * @return
     */
    boolean updatePassword(int id, String password,String oldPassword);
```



 [UserServiceImpl.java](src\main\java\com\nowcoder\community\service\impl\UserServiceImpl.java) 

```java
    @Override
    public boolean updatePassword(int id, String password,String oldPassword) {
        //校验旧密码
        User user = userMapper.selectById(id);
        oldPassword=CommunityUtil.MD5(oldPassword+user.getSalt());
        if (!user.getPassword().equals(oldPassword)) {
            return false;
        }

        //插入新密码
        String salt = user.getSalt();
        password = CommunityUtil.MD5(password + salt);
        int count = userMapper.updatePassword(id,password);

        return count > 0;
    }
```





### controller

 [UserController.java](src\main\java\com\nowcoder\community\controller\UserController.java) 

```java
  //修改密码
    @PostMapping("/updatePassword")
    public String updatePassword(Model model, UpdatePasswordFrom updatePasswordFrom){
        User user = hostHolder.getUser();
        Integer id = user.getId();
        String newPassword = updatePasswordFrom.getNewPassword();
        String oldPassword = updatePasswordFrom.getOldPassword();
        String confirmPassword = updatePasswordFrom.getConfirmPassword();

        if(!confirmPassword.equals(newPassword)){
            throw new RuntimeException("两次输入的密码不一致");
        }

        boolean count = userService.updatePassword(id, newPassword, oldPassword);
        if (count==false){
            throw new RuntimeException("更新密码失败，旧密码错误或者dao调用失败");
        }
        return "redirect:/index";
    }
```



### 模板

```html
<form class="mt-5" method="post" th:action="@{/user/updatePassword}">

    <input type="password" class="form-control" id="old-password"
           name="oldPassword" placeholder="请输入原始密码!" required>

    <input type="password" class="form-control" id="new-password"
           name="newPassword" placeholder="请输入新的密码!" required>

    <input type="password" class="form-control" id="confirm-password"
           name="confirmPassword" placeholder="再次输入新密码!" required>
    <button type="submit" class="btn btn-info text-white form-control">立即保存</button>
</form>
```

















## 帖子(DiscussPost)



### 分布帖子（异步）

> 主要是使用了敏感词过滤，其他没啥了



#### mapper

```java
    int insert (DiscussPost discussPost);
```



#### service

```java
@Autowired
private SensitiveFilter sensitiveFilter;

@Override
public int insertPost(DiscussPost discussPost) {
    if (discussPost == null) {
        throw new RuntimeException("数据为空");
    }

    //转义xml语言
    String title = HtmlUtils.htmlEscape(discussPost.getTitle());
    String content =HtmlUtils.htmlEscape(discussPost.getContent());
    //过滤敏感词
    discussPost.setTitle(sensitiveFilter.filter(title));
    discussPost.setContent(sensitiveFilter.filter(content));
    return discussPostMapper.insert(discussPost);
}
```

> - 转义xml语言，防止被攻击 `HtmlUtils.htmlEscape`





#### 实体

```java
public class Result {
    private Integer code;
    private Object data;
    private String msg;
}
```





#### controller

```java
//异步请求的控制器，返回的一般只有数据
@Controller
@RequestMapping("/discuss")
public class DiscussPostController {

    @Autowired
    private DiscussPostService discussPostService;

    @Autowired
    private HostHolder hostHolder;

    /**
     * 添加帖子，有手就行
     * @param title 标题
     * @param content 内容
     * @return
     */
    @PostMapping("/add")
    @ResponseBody
    public Result addDiscussPost(String title, String content) {
        User user = hostHolder.getUser();
        if (user == null) {
            return new Result(403, null, "没有登入");
        }
        DiscussPost discussPost = new DiscussPost(user.getId(), title, content, new Date());
        discussPost.setType(0);
        discussPost.setStatus(0);
        discussPost.setCommentCount(0);
        discussPost.setScore(0.0);
        int count = discussPostService.insertPost(discussPost);
        return new Result(0, null, "插入评论成功");
    }
}
```

> //异步请求的控制器，返回的一般只有数据
>
> - 进一步了解为什么会由异步请求了，这里只请求了数据，这才是前后端分离之后的内容













### 帖子详情

service

```java
 DiscussPost findPostById(Integer id);
```



controller

```java
/**
 * 显示详细内容，有手就行
 * @param discussPostId 帖子id
 * @param model
 * @return
 */
@GetMapping("/detail/{discussPostId}")
public String getDiscussPost(@PathVariable("discussPostId") int discussPostId, Model model) {
    // 帖子
    DiscussPost post = discussPostService.findPostById(discussPostId);
    // 找作者,这里进行了两次查询表，可以说是比较低效的，可以在dao层使用联表查询，是业务就重叠了
    //到时使用reids优化
    User user = userService.selectById(post.getUserId());

    model.addAttribute("post", post);
    model.addAttribute("user", user);

    return "/site/discuss-detail";
}
```





#### 帖子详细进阶

![image-20230613193025727](./assets/image-20230613193025727.png)

> 这部分的内容和[上面的分页查询类似](#controller的查询封装做法)（前端page --> page --> 初始行、limit --> 查询表），但是在查询表数据更加复杂了
>
> - 这里可以发现page 可以复用，可以说是比较好用的东西，接收前端的数据，得到查询表所需要的 `初始行、limit` 



#### E-R结构

![image-20230613185616476](./assets/image-20230613185616476.png)



> 主要是comment评论表，还有帖子表的comment_count字段



#### 实体

```java
public class Comment {
    Integer id;
    Integer userId;
    Integer entityType;
    Integer entityId;
    Integer targetId;
    String content;
    Integer status;
    Date createTime;、
}
```

> 还有就是page对象，这玩意有额外的功能



#### mapper

> 没啥新东西，就是一个帖子的评论总数，一个帖子的分页数据

```java
//评论
@Mapper
public interface CommentMapper {
    List<Comment> selectCommentByEntity(@Param("entityType") Integer entityType,
                                        @Param("entityId") Integer entityId,
                                        @Param("offset") Integer offset,
                                        @Param("limit") Integer limit);

    int selectCountByEntity(@Param("entityType") Integer entityType,
                            @Param("entityId") Integer entityId);
```



#### contorller

```java
@Autowired
private UserService userService;

@Autowired
private CommentService commentService;

/**
 * 显示详细内容，手脚并用都不行
 *
 * @param discussPostId 帖子id
 * @param model
 * @return
 */
@GetMapping("/detail/{discussPostId}")
public String getDiscussPost(@PathVariable("discussPostId") int discussPostId, Page page, Model model) {
    //1、帖子
    DiscussPost post = discussPostService.findPostById(discussPostId);
    // 找作者,这里进行了两次查询表，可以说是比较低效的，可以在dao层使用联表查询，是业务就重叠了
    //到时使用reids优化
    User user = userService.selectById(post.getUserId());

    //2、 评论、回复
    //前端的所需要的数据处理
    page.setLimit(5);
    page.setRows(post.getCommentCount());//直接拿帖子表的评论数
    page.setPath("/discuss/detail/" + discussPostId);

    //查询评论表对于帖子的评论
    List<Comment> commentList = commentService.selectCommentByEntity(ENTITY_TYPE_POST, discussPostId, page.getOffset(), page.getLimit());
    //评论：对于帖子的评论
    List<Map<String, Object>> commentVoList = new ArrayList<>();

    if (commentList != null) {
        for (Comment comment : commentList) {
            Map<String, Object> commentVo = new HashMap<>();

            commentVo.put("comment", comment);//评论
            commentVo.put("user", userService.selectById(comment.getUserId()));//作者

            //查询评论表对于评论的评论
            List<Comment> replyList = commentService.selectCommentByEntity(ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);
            //回复：对于评论的评论，所以嵌套到评论循环中
            List<Map<String, Object>> replyVoList = new ArrayList<>();
            if (replyList != null) {
                for (Comment reply : replyList) {
                    Map<String, Object> replyVo = new HashMap<>();

                    replyVo.put("reply", reply);//回复
                    replyVo.put("user", userService.selectById(reply.getUserId()));//作者
                    User target = reply.getTargetId() == 0 ? null : userService.selectById(reply.getTargetId());
                    replyVo.put("target", target);//回复对象

                    replyVoList.add(replyVo);
                }
            }

            commentVo.put("replys", replyVoList);

            // 回复数量
            int replyCount = commentService.selectCountByEntity(ENTITY_TYPE_COMMENT, comment.getId());
            commentVo.put("replyCount", replyCount);

            //总对象，变态对象
            commentVoList.add(commentVo);
        }


        model.addAttribute("post", post);
        model.addAttribute("user", user);
    }


    model.addAttribute("comments", commentVoList);

    return "/site/discuss-detail";
}
```

> 可以说是又长又臭，但是主要逻辑确实和[上面的一致](#controller的查询封装做法)，只是返回前端的数据结构复杂了

![image-20230613192955077](./assets/image-20230613192955077.png)















## 评论（Comment）

> 实际上，帖子详细就已经涉及到了评论表的内容



### 添加评论(异步)

![image-20230616110508276](./assets/image-20230616110508276.png)



#### mapper

```java
//评论
@Mapper
public interface CommentMapper {
    List<Comment> selectCommentByEntity(@Param("entityType") Integer entityType,
                                        @Param("entityId") Integer entityId,
                                        @Param("offset") Integer offset,
                                        @Param("limit") Integer limit);

    int selectCountByEntity(@Param("entityType") Integer entityType,
                            @Param("entityId") Integer entityId);

    int insertComment(Comment comment);
}
```



```java
@Mapper
public interface DiscussPostMapper {
   /**
     * 更新帖子的评论数量，不包括帖子评论的回复
     * @param id 帖子的id
     * @return
     */
    int updateCommentCount(@Param("id") Integer id, @Param("commentCount") Integer commentCount);
}
```









#### service

```java
public interface CommentService {

    /**
     * @param entityType 评论的对象：帖子/评论的评论
     * @param entityId   评论的帖子的id
     * @return
     */
    List<Comment> selectCommentByEntity(Integer entityType,
                                        Integer entityId,
                                        Integer offset,
                                        Integer limit);

    /**
     * @param entityType 评论的对象：帖子/评论的评论
     * @param entityId   评论的帖子的id
     * @return
     */
    int selectCountByEntity(Integer entityType,
                            Integer entityId);

    int addComment(Comment comment);
}
```



> 主要注意的是addComment方法，涉及了[事务管理](D:\workplace\JavaWeb_Video\MyNote\Spring\声明式事务管理.md#使用注解替代xml)

```java
@Override
@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)
public int addComment(Comment comment) {
    if (comment == null) {
        throw new RuntimeException("评论为空");
    }

    String htmlEscape = HtmlUtils.htmlEscape(comment.getContent());//过滤xml
    String contentAfterFilter = sensitiveFilter.filter(htmlEscape);//过滤敏感词
    comment.setContent(contentAfterFilter);

    int rows = commentMapper.insertComment(comment);
    //假如评论的是帖子,更新帖子表的评论数
    if (comment.getEntityType() == ENTITY_TYPE_POST) {
        DiscussPost post = discussPostService.findPostById(comment.getEntityId());
        discussPostService.updateCommentCount(comment.getEntityId(), post.getCommentCount() + rows);
    }
    return rows;
}
```













#### controller

```java
//添加评论
//异步请求的控制器，返回的一般只有数据
@Controller
@RequestMapping("/comment")
public class CommentController {

    @Autowired
    private CommentService commentService;

    @Autowired
    private HostHolder hostHolder;

    @PostMapping("/add/{discussPostId}")
    public String getDiscussPost(@PathVariable("discussPostId") int discussPostId, Comment comment) {

        User user = hostHolder.getUser();
        comment.setUserId(user.getId());
        comment.setStatus(0);
        comment.setCreateTime(new Date());
        
        int count = commentService.addComment(comment);

        return "redirect:/discuss/detail/"+discussPostId;
    }
}
```













## 私信(Message)

> 在看这玩意之前
>
> - 会话：两个用户之间最新私信，比如111用户看到的会话列表应该是112、113、114...的最新一次私信
> - 具体私信：两个用户之间私信，比如111用户点击进入查看和112的私信

### E-R图

<img src="./assets/image-20230616122319043.png" alt="image-20230616122319043" style="zoom:50%;" />

> 需要注意的只有conversation_id ： 为的其实是简化查询会话的
>
> 而且由于双方收发的私信在同一张表，所以到时返回前端，无论是会话还是私信都要告诉他target(接收用户)是谁



### 私信列表



#### mapper

> 这些mapper比较复杂，尤其是前5个

```java
@Mapper
public interface MessageMapper {


    //1、 查询当前用户的会话列表,针对每个会话只返回一条最新的私信.
    List<Message> selectConversations(@Param("userId") int userId, @Param("offset") int offset, @Param("limit") int limit);

    //2、 查询当前用户的会话数量.
    int selectConversationCount(int userId);

    //3、 查询某个会话所包含的私信列表.
    List<Message> selectLetters(@Param("conversationId") String conversationId, @Param("offset") int offset, @Param("limit") int limit);

    //4、 查询某个会话所包含的私信数量.
    int selectLetterCount(String conversationId);

    //5 、查询未读私信的数量：一个会话的或者全部的
    int selectLetterUnreadCount(@Param("userId") int userId, @Param("conversationId") String conversationId);

    int insertMessage(Message message);

    int updateStatus(@Param("ids") List<Integer> ids, @Param("status") Integer status);
}
```



service没干活



#### Controller

`MessageController`

> 又来了，超复杂的数据结构，一定要清楚会话、私信的区别



- 1. ==会话==

```java
//会话
@GetMapping("/letter/list")
public String getLetterList(Page page, Model model) {

    User user = hostHolder.getUser();

    page.setLimit(5);
    page.setPath("/letter/list");
    page.setRows(messageService.findConversationCount(user.getId()));

    //数据查询封装
    List<Message> conversationList = messageService.findConversations(user.getId(), page.getOffset(), page.getLimit());
    List<Map<String, Object>> conversations = new ArrayList<>();
    if (conversationList != null) {
        for (Message conversation : conversationList) {
            HashMap<String, Object> map = new HashMap<>();
            int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), conversation.getConversationId());
            int letterCount = messageService.findLetterCount(conversation.getConversationId());
            //当前用户是发送还是接收？
            int targetId = user.getId() == conversation.getFromId() ? conversation.getToId() : conversation.getFromId();

            map.put("conversation", conversation);
            map.put("unreadCount", letterUnreadCount);
            map.put("letterCount", letterCount);
            //毕竟查出来的数据只知道双方的会话，不知道是谁接收
            map.put("target", userService.selectById(targetId));
            conversations.add(map);
        }
    }

    // 查询未读消息数量
    int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);
    model.addAttribute("letterUnreadCount", letterUnreadCount);

    model.addAttribute("conversations", conversations);
    return "/site/letter";
}
```

> 1. 额，不用@GetMapping修饰类是由于待会有其他方法
> 2. 

![image-20230616122946757](./assets/image-20230616122946757.png)



- 2. ==详细私信==



```java
//1、某个会话的私信
@GetMapping("/letter/detail/{conversationId}")
public String getLetterDetail(Page page, Model model, @PathVariable String conversationId) {

    page.setLimit(5);
    page.setPath("/letter/detail/" + conversationId);
    page.setRows(messageService.findLetterCount(conversationId));

    //2、数据封装
    List<Message> letterList = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());
    List<Map<String, Object>> letters = new ArrayList<>();

    if (letterList != null) {
        for (Message message : letterList) {
            Map<String, Object> map = new HashMap<>();
            map.put("letter", message);
            map.put("fromUser", userService.selectById(message.getFromId()));
            letters.add(map);
        }
    }

    model.addAttribute("letters", letters);
    //3、私信目标，其实和上面的逻辑一样，当前用户是发送还是接收？
    model.addAttribute("target", getLetterTarget(conversationId));

    //4、更新私信的已读状态
    List<Integer> ids = getLetterIds(letterList);
    if (!ids.isEmpty()) {
        messageService.updateStatus(ids);
    }

    return "/site/letter-detail";
}

//私信的接受者是谁
private User getLetterTarget(String conversationId) {
    String[] ids = conversationId.split("_");
    int id0 = Integer.parseInt(ids[0]);
    int id1 = Integer.parseInt(ids[1]);

    // 假如当前用户是某个会话的发送方，则对方为target
    // 假如当前用户是某个会话的接收方，则我方为target
    if (hostHolder.getUser().getId() == id0) {
        return userService.selectById(id1);
    } else {
        return userService.selectById(id0);
    }
}

//遍历私信列表，更新已读状态
private List<Integer> getLetterIds(List<Message> letterList) {
    List<Integer> ids = new ArrayList<>();

    if (letterList != null) {
        for (Message message : letterList) {
            //假如当前用户为接受者,注意的是已读状态只有接受者可以改，注意引用类型使用equals
            if (hostHolder.getUser().getId().equals(message.getToId()) && message.getStatus() == 0) {
                ids.add(message.getId());
            }
        }
    }

    return ids;
}
```

> 这个结构就没啥好看的，一样的流程，就是`私信的接受者是谁`、`更新已读状态`这两段逻辑看看就好















### 发私信（异步）



mapper省略

#### service

> `MessageServiceImpl`：反正用户的东西一定要检查

```java
@Autowired
private SensitiveFilter sensitiveFilter;

@Override
public int insertMessage(Message message) {
    String htmlEscape = HtmlUtils.htmlEscape(message.getContent());
    message.setContent(sensitiveFilter.filter(htmlEscape));

    return messageMapper.insertMessage(message);
}

@Override
public int updateStatus(List<Integer> ids) {
    return messageMapper.updateStatus(ids,1);
}
```



#### controoler

`MessageController`

```java
//发私信
@PostMapping("/letter/send")
@ResponseBody
public Result sendLetter(String toName, String content) {

    Integer fromUserId = hostHolder.getUser().getId();
    Integer toUserId = userService.selectByName(toName).getId();
    if (toUserId == null) {
        return new Result(1, null, "目标用户不存在!");
    }

    //数据封装
    String conversationId = fromUserId <= toUserId ?
            fromUserId + "_" + toUserId
            : toUserId + "_" + fromUserId;

    Message message = new Message(fromUserId, toUserId, conversationId, content, 0, new Date());

    int count = messageService.insertMessage(message);

    return new Result(0, null, "发送私信成功");
}
```

















# 调试

## 状态码

> 响应状态码主要分为几种
>
> - 2xx：成功
> - 3xx：重定向
> - 4xx：url找不到对应的controller
> - 5xx：服务器出错
>
> [官网](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/100)
>
> [状态码](D:\workplace\JavaWeb_Video\MyNote\Web核心\BS模型.md#2.4响应数据格式)
>
> [重定向原理详细原理](D:\workplace\JavaWeb_Video\MyNote\Web核心\sevlet_req_and_resp.md#Respones请求重定向)



### 重定向

这里简述一下重定向的原理

<img src="./assets/image-20230526203440818.png" alt="image-20230526203440818" style="zoom:40%;" />

> 程序都是讲究耦合的，删除的contoller去调用查询这是不好的，所以需要客户端重定向导查询



<img src="./assets/image-20230526203636393.png" alt="image-20230526203636393" style="zoom:40%;" />













## 断点调试

### 后端

![image-20230526204703631](./assets/image-20230526204703631.png)









### 前端



![image-20230526105040225](./assets/image-20230526105040225.png)









## 日记

### 测试

[官网](https://logback.qos.ch/manual/architecture.html)

> 级别：trace、debug、info、warn、error
>
> 显性的输出日记

```java
//首先声明是使用spring的测试类
@RunWith(SpringRunner.class)
@SpringBootTest
public class LoggerTests {

    //加载需要启动日记的类/包
   private Logger logger = LoggerFactory.getLogger(LoggerTests.class);

   @Test
    public void loggerOut(){
       System.out.println(logger.getName());	//是谁启动了日记
        
       logger.debug("debug log");				//输出对应的级别
       logger.info("info log");
       logger.warn("warn log");
       logger.error("error log");
   }
}
```

当然：会受到配置的影响，假如输出大于debug类型，则效果不同





### yaml配置

> 默认为info级别，默认输出导控制台
>
> 下面的级别，假如大于debug都会输出

![image-20230526111243124](./assets/image-20230526111243124.png)









### 配置文件

> 按照不同的级别输出为不同文件
>
> [官网](https://logback.qos.ch/manual/configuration.html)

![image-20230526194803201](./assets/image-20230526194803201.png)

> 优先：配置文件 > yaml

























# 额外功能

## 邮箱发送

这里使用Spring Email

> - 邮箱设置
>   - 启用客户端SMTP服务
> - Spring Email
>   - 导入jar 包
>   - 邮箱参数配置
>   - 使用JavaMailSender 发送邮件
> - 模板引擎
>   - 使用Thymeleaf发送HTML 邮件



### 导包

>  学会使用maven仓库搜索并使用最实用的版本，[spring mail](https://mvnrepository.com/search?q=spring+mail)



```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
    <version>2.2.6.RELEASE</version>
</dependency>
```





### 配置

> springboot的配置要学会使用[文档](https://springdoc.cn/spring-boot/io.html#io.email)
>
> 网易云的smtp的host ： `smtp.163.com` [参考](https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2a5feb28b66796d3b)
>
> 网易云的password：[参考](https://blog.csdn.net/lx_nhs/article/details/83146206)

```yaml
spring:
  #mail的配置
  mail:
  	#域名端口
    host: smtp.163.com
    port: 465
	#账号
    username: jumpupchen@163.com
    #网易授权码
    password: GMPQHBEGANHCHBNF
    protocol: smtps	#加密协议
    properties:
      mail.smtp.ssl.enable: true	#ssl安全连接
```

​	



### JavaMailSender工具类

> 使用工具类方便日后重用
>
> helper[参考](https://docs.spring.io/spring-framework/docs/6.0.5/reference/html/integration.html#mail-javamail-mime)



- `/util/MailClient`

```java
//工具类大多都是可重用的bean
@Component
public class MailClient {

    //单独的配置该类的输出日志，比如平时其他类要是出错不会输出自定义的信息，
    // 这和aop不太一样，这里只是输出日志，没法处理
    private Logger logger = LoggerFactory.getLogger(MailClient.class);

    //使用springBoot的JavaMailSender，他会加载yaml的信息
    @Autowired
    private JavaMailSender mailSender;

    //该bean的主要方法
    public void sendMail(String to, String subject, String content) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message);
            helper.setFrom("jumpupchen@163.com");//谁发信息，需要和配置文件的一致
            helper.setTo(to);//发给谁
            helper.setSubject(subject);//标题
            helper.setText(content,true);//内容+开启html模式
            mailSender.send(helper.getMimeMessage());//发送
        } catch (MessagingException e) {
            logger.error("发送邮件失败"+e.getMessage()); //日志输出
        }
    }
}
```







### 测试一下1



- 测试类

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class MailTest {

    @Autowired
    private MailClient mailClient;

    @Autowired
//    注入模板引擎
    private TemplateEngine templateEngine;

    //发送文本试试
    @Test
    public void testMail(){     
        mailClient.sendMail("1811546213@qq.com","hello","xiaojian");
    }
    
    //发送html试试
    @Test
    public void testHtmlMail(){
        //传给模板的属性
        Context context = new Context();
        context.setVariable("msg","xiaojian");
        //使用模板引擎渲染并返回html
        String message = templateEngine.process("/mail/demo.html", context);
        System.out.println(message);

        mailClient.sendMail("1811546213@qq.com","html",message);
    }


}
```



- 模板`/mail/demo.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<i style="color: red">hello [[${msg}]]</i>
</body>
</html>
```











## commons-lang工具类

> 这个工具类本质可以像java.lang工具类一样使用，很方便

[工具类的使用](https://blog.csdn.net/wang_jing_jing/article/details/119182699)

### 导包

[导包](https://mvnrepository.com/artifact/org.apache.commons/commons-lang3/3.12.0)

```xml
<!--        commons-lang3工具-->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.12.0</version>
        </dependency>
```



### 使用工具类

- 生成随机数：这里只是说明commons-lang的使用，[参考](https://blog.csdn.net/wang_jing_jing/article/details/119182699)
- 以下两个方法没有使用commons-lang
  - uuid生成：唯一的随机数，使用java原生的生成的数据原本为（`20971348-d91e-4b63-be2c-0d9d02aa1dab`）
  - MD5加密: 这里使用springBoot的整合的玩意

```java
public class CommunityUtil {
    
    public static String randomTest(){
//        生成指定长度的字母和数字组成的随机组合字符串
//        https://blog.csdn.net/wang_jing_jing/article/details/119182699
        return RandomStringUtils.randomAlphanumeric(32);
    }
    
    public static String generateUUID(){
        //java生成uuid的办法，将‘-’替换位”“ ，生成的是32位的16进制数
        return UUID.randomUUID().toString().replaceAll("-", "");
    }

    /**springBoot整合了md5
     * @param key: password+salt
     * @return
     */
    public static String MD5(String key){
        if (StringUtils.isBlank(key)) {
            return null;
        }
        return DigestUtils.md5DigestAsHex(key.getBytes());
    }
}
```



<img src="./assets/image-20230528221951590.png" alt="image-20230528221951590" style="zoom:50%;" />

> 需要注意的是到时加入到数据库就不可以当当是password了
>
> - salt
> - PASSWORD

### 测试一下2

```java
//salt和md5
String salt= CommunityUtil.generateUUID().substring(0,5);//截取0到4，不包括5
String password=CommunityUtil.MD5(user.getPassword()+salt);

//32位激活码，因为本质就是数据数就行
String activationCode=CommunityUtil.generateUUID();
```





## 验证码工具



### 导包

[maven](https://mvnrepository.com/artifact/com.github.penggle/kaptcha/2.3.2)

```xml
        <dependency>
            <groupId>com.github.penggle</groupId>
            <artifactId>kaptcha</artifactId>
            <version>2.3.2</version>
        </dependency>
```



### 配置类

```java
@Configuration
public class KaptchaConfig {

    @Bean
    public DefaultKaptcha kaptcha(){
        //配置信息，当然也可以搞到yaml，但是这里偷懒直接拷贝了
        Properties properties = new Properties();
        properties.setProperty("kaptcha.image.width", "100");
        properties.setProperty("kaptcha.image.height", "36");
        properties.setProperty("kaptcha.textproducer.font.size", "30");
        properties.setProperty("kaptcha.obscurificator.impl", "com.google.code.kaptcha.impl.ShadowGimpy");
        properties.setProperty("kaptcha.session.key", "code");
        properties.setProperty("kaptcha.noise.impl", "com.google.code.kaptcha.impl.NoNoise");
        properties.setProperty("kaptcha.textproducer.char.length", "4");

        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();
        Config config =new Config(properties);
        defaultKaptcha.setConfig(config);
        return defaultKaptcha;
    }
}
```



### 使用

```java
    @Autowired
    private DefaultKaptcha kaptcha;

//或者他的父接口
    @Autowired
    private Producer producer;

		//获取验证码
        String text = kaptcha.createText();
		//获取图片流
        BufferedImage img = kaptcha.createImage(text);
```

















## user线程绑定



```java
@Component
public class HostHolder {

    //虽然是bean了，不会有新建HostHolder的事情导致ThreadLocal也新建，导致一个线程每次访问ThreadLocal都不是同一个
    //这里保险的使用了static，不会出现上面的数据不完整
    private static ThreadLocal local = new ThreadLocal<User>();

    public void setUser(User user) {
        local.set(user);
    }

    public User getUser() {
        return (User) local.get();
    }

    public void clean() {
        local.remove();
    }
}
```

> ThreadLocal是静态的变量，防止有意外，反正这种和线程安全或者可重用的玩意是要考虑static的,[使用看](#显示用户信息)
>
> 详细看java杂谈









## getCookie工具



```java
public class CookieUtil {
    /**
     * @param request 请求
     * @param name  cookie的属性名称
     * @return cookie的值
     */
    static public String getValue(HttpServletRequest request, String name) {

        //判断为空永远再最前面
        if(request==null|| name == null){
            throw new RuntimeException("请求对象为空或者名称为空");
        }

        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(name)) {
                    return cookie.getValue();
                }
            }
        }
        return null;
    }
}

```

[使用看](#显示用户信息)

> 再判断为空面前吃了亏

















## 常量接口

```java

public interface CommunityConstant {
    /**
     * 激活成功
     */
    static final int ACTIVATION_SUCCESS = 0;

    /**
     * 重复激活
     */
    static final int ACTIVATION_REPEAT = 1;

    /**
     * 激活失败
     */
    static final int ACTIVATION_FAILURE = 2;
    
     /**
     * 默认登入凭证的超时时间
     */
    static final int DEFAULT_EXPIRED_SECONDS=3600*12;

    /**
     * 勾选记住我的登入凭证的超时时间
     */
    static final int REMEMBER_EXPIRED_SECONDS=3600*24*100;
}

```





其他地方使用就要 `implements CommunityConstant`

```java
result == ACTIVATION_SUCCESS
```

使用CommunityConstant的常量用implements好还是import static好，都一样，反正使用static也可以，还不用`implements CommunityConstant`















## 图片流传输

### 前端--> 后端

目前只有http的from表单post请求发送，springMvc接收的形式，[可以看看](D:\workplace\JavaWeb_Video\MyNote\Web核心\BS模型.md#post请求数据类型)

#### 请求

```html
<form class="mt-5" method="post" enctype="multipart/form-data" th:action="@{/user/upload}">
.....
    <div class="form-group row mt-4">
        <div class="col-sm-2"></div>
        <div class="col-sm-10 text-center">
            <button type="submit" class="btn btn-info text-white form-control">立即上传</button>
        </div>
    </div>
</form>
```

#### 接收

```java
@PostMapping("/upload")
    public String uploadImage(MultipartFile headerImage) {}
```





### 图片存储/后端--> 前端

三种方法

> 看完之后，会发现其实流的产生很多时候不需要我们手动创建，比如下面的`new fileOutpustream` 可以直接从`OutputStream os = response.getOutputStream();`得到，http返回图片到浏览器
>
> - 注意：
>
>   http返回图片到浏览器，需要告知浏览器是什么类型的图片，[详细看](D:\workplace\JavaWeb_Video\MyNote\Web核心\BS模型.md#2.4响应数据格式)





#### 首先就是springMVC的MultipartFile

![image-20230608232128659](./assets/image-20230608232128659.png)

```java
@PostMapping("/upload")
    public String uploadImage(MultipartFile headerImage) {
         File file = new File(uploadPath + "/" + imageName);
         headerImage.transferTo(file);
    }
```





#### 全能格式

<img src="./assets/image-20230608231027106.png" alt="image-20230608231027106" style="zoom:50%;" />

```java
    //本地文件夹
    @Value("${community.path.upload}")
    private String uploadPath;

    @Test
    public void testImageIO() throws Exception {
        String imagePath = uploadPath + "/" + "1.png";
        InputStream inputStream = new FileInputStream(new File(imagePath));
        OutputStream outputStream = new FileOutputStream(uploadPath + "/" + "2.png");
        
        byte[] buffer = new byte[1024];
        int b = 0;
        while ((b = inputStream.read(buffer)) != -1) {//一次性读一k
            System.out.println("一次性读" + b); //一次性写一k
            outputStream.write(buffer, 0, b);
        }
    }
```



#### ImageIO工具类

<img src="./assets/image-20230608231535138.png" alt="image-20230608231535138" style="zoom:50%;" />

```java
    //本地文件夹
    @Value("${community.path.upload}")
    private String uploadPath;

    @Test
    //参考 https://blog.csdn.net/u012581020/article/details/130625872
    public void testImageIO() throws Exception {
        String imagePath = uploadPath + "/" + "1.png";
        InputStream inputStream = new FileInputStream(new File(imagePath));

        //放到内存中并封装一下,read( File、InputStream、URL 和 ImageInputStream类型都行)
        BufferedImage readImage = ImageIO.read(inputStream);
        //写到磁盘，write的输入流只支持BufferedImage
        ImageIO.write(readImage, "png", new File(uploadPath +"/"+ "2.png"));
        inputStream.close();
        outputStream.close();
    }
```





















## 拦截器的其它实现方法

> [之前的是](#拦截器)
>
> 就是使用注解拦截，而不是配置拦截，回想一下aop不也是这玩意：可以使用注解拦截，也可以xml配置拦截

这里的注解拦截使用的是自行编写的注解

<img src="./assets/image-20230608205723399.png" alt="image-20230608205723399" style="zoom:50%;" />

> 很明显：好处就是不需要一个一个配置到配置类，使用注解到对应的请求方法即可





### 注解接口

`/annotation.LoginRequired`

```java
/**
 * 标识需要登入才能访问的请求
 */
@Target({ElementType.METHOD, ElementType.TYPE}) // 元注解，在方法和文件上用
@Retention(RetentionPolicy.RUNTIME) // 一直活着，在运行阶段这个注解也不消失
public @interface LoginRequired {
}

```





### 拦截器解析注解

```java
/**
 * 拦截需要登入才能访问的请求，为的就是不需要一个一个的写配置中
 */
@Component
public class LoginRequiredInterceptor implements HandlerInterceptor {

    @Autowired
    private HostHolder hostHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
                if(handler instanceof HandlerMethod){
            //拦截器参数问题n
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            Method method = handlerMethod.getMethod();
            //注解解析问题
            if (method.isAnnotationPresent(LoginRequired.class) && hostHolder.getUser()==null) {
                //重定向问题
                response.sendRedirect(request.getContextPath()+"/index");
                return false;
            }
        }
        return true;
    }
}
```

> if(handler instanceof HandlerMethod){} 需要判断请求的是不是方法类型







### 最后配置拦截器

```java
@Configuration
public class WebMvcSupport implements WebMvcConfigurer {

    @Autowired
    private LoginRequiredInterceptor loginRequiredInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginRequiredInterceptor)
                .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");
    }
}
```





### 使用

```java
    @LoginRequired
    @GetMapping("/setting")
```











## [date传输](D:\workplace\JavaWeb_Video\MyNote\SpringMVC\SpringMVC入门.md#4.5 日期类型参数传递)

### +时间戳

```java
 @Test
    public void testDate() {
//        参考: https://blog.csdn.net/weixin_45948234/article/details/112178525
        long timeMillis = System.currentTimeMillis();
        timeMillis += 3600 * 1000;  //以毫秒计算
        System.out.println("没有格式化的时间戳" + timeMillis);

        Date date = new Date(timeMillis);
        System.out.println("强转的时间戳" + date);

        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z");
        System.out.println("格式化的时间戳" + formatter.format(timeMillis));
    }

```

> 好处：
>
> - 比较时间大小，当然[使用这个也行](https://blog.csdn.net/chenpp666/article/details/125172674)
> - 时间运算

















## 过滤敏感词

> 本质是双指针的算法，使用的数据结构为前缀树



![](./assets/image-20230610230305571.png)







- **util/[SensitiveFilter.java](src\main\java\com\nowcoder\community\util\SensitiveFilter.java)** 

### 数据结构

```java
@Component
public class SensitiveFilter {

    private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);

    // 替换符
    private static final String REPLACEMENT = "***";

    // 根节点
    private TrieNode rootNode = new TrieNode();

    //bean的生命周期！类似的东西
    @PostConstruct
    public void init() {
        //java自动关闭流
        try (
                //this的作用域
                InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("sensitive-words.txt");
                //加个缓冲流,可以一次读一行
                BufferedReader words = new BufferedReader(new InputStreamReader(inputStream));
        ) {
            String keyword;
            //一个一个的单词的存放到前缀树中
            while ((keyword = words.readLine()) != null) {
                rootNode.addSubNode(keyword);
            }
        } catch (IOException e) {
            logger.error("加载敏感词文件失败: " + e.getMessage());
        }
    }


    //敏感词加入到前缀树中，没有实现其他功能是因为这里只用到了遍历判断节点是否存在
    private class TrieNode {
        //这里省略了pass
        //最终节点标识end，没有额外的功能，只是标志为一个word的结束
        private boolean end = false;
        //子节点的字符，嵌套子节点
        private Map<Character, TrieNode> subNode = new HashMap<>();

        public boolean isEnd() {
            return end;
        }

        public void setEnd(boolean end) {
            this.end = end;
        }

        public void addSubNode(String word) {
            TrieNode node = this; //从根节点开始
            for (Character c : word.toCharArray()) {   //遍历字符串
                if (node.getSubNode(c) == null) {       //该字符不存在
                    node.subNode.put(c, new TrieNode());
                }
                node = node.getSubNode(c);  //进入下一个子节点
            }
            node.setEnd(true);  //最终节点设置为真， 设置结束标识
        }

        //获取默认子节点
        public TrieNode getSubNode(Character c) {
            return subNode.get(c);
        }
    }


    /**
     * 双指针过滤敏感词
     *
     * @param text 待过滤的文本
     * @return 过滤后的文本
     */
    public String filter(String text) { }


    // 判断是否为符号
    private boolean isSymbol(Character c) {
        // 0x2E80~0x9FFF 是东亚文字范围
        return !CharUtils.isAsciiAlphanumeric(c) && (c < 0x2E80 || c > 0x9FFF);
    }
}

```

> 还没开始就涉及了一堆东西
>
> - bean的生命周期类似的东西：`@PostConstruct`，[参考](D:\workplace\JavaWeb_Video\MyNote\Spring\spring入门IOC.md#3.4.3 bean对象生命周期)，比bean的生命周期还早[参考](https://blog.csdn.net/sunayn/article/details/92840439)
> - try() catch : 自动关闭流
> - [this](D:\workplace\JavaWeb_Video\MyNote\JavaBase\java乱套.md#this关键字)：指向调用者，[getclass()](D:\workplace\JavaWeb_Video\MyNote\JavaBase\Java进阶.md#路径问题) :类路径
> - InputStream(一次读1k) --> InputStreamReader -->  BufferedReader (一次读一行)
> - rootNode.addSubNode(keyword) ： [前缀树插入、创建](D:\workplace\LeetCode\tree\前缀树.md)



### 算法具体实现

<img src="./assets/image-20230610230848307.png" alt="image-20230610230848307" style="zoom:50%;" />

```java
/**
     * 双指针过滤敏感词
     *
     * @param text 待过滤的文本
     * @return 过滤后的文本
     */
    public String filter(String text) {
        if (StringUtils.isBlank(text)) {
            return null;
        }

        //树的指针
        TrieNode node = rootNode;
        int begin = 0;
        int end = 0;
        // 结果
        StringBuilder sb = new StringBuilder();

        //这里使用while，由于会有指针回退的效果和一个指针一直向前走，但是另一个指针回回退反复走，是不可以使用for的
        while (begin < text.length()) {
            if (end < text.length()) {
                char c = text.charAt(end);

                // 跳过符号
                if (isSymbol(c)) {
                    // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步
                    if (node == rootNode) {
                        sb.append(c);
                        begin++;
                    }
                    // 无论符号在开头或中间,指针3都向下走一步
                    end++;
                    continue;
                }

                node = node.getSubNode(c);//子节点
                if (node == null) {         		//字母不在树中
                    sb.append(text.charAt(begin));
                    end = ++begin;//end回退
                    node = rootNode;
                } else if (node.isEnd()) {  		//敏感词出现
                    sb.append(REPLACEMENT);
                    begin = ++end;
                    node = rootNode;
                } else {                    		//字母在树中且不是end
                    ++end;
                }
            } else { 								//end突破了
                sb.append(text.charAt(begin));
                end = ++begin;//end回退
                node = rootNode;
            }
        }

        return sb.toString();
    }
```







### 工具类使用



#### 敏感词文件

/resources/ [sensitive-words.txt](src\main\resources\sensitive-words.txt) 



#### test

```java
    @Test
    public void testSensitiveFilter() {
        String text = "这里可以赌博嫖娼,可以嫖1娼,可以吸毒,可以开票,哈哈哈!嫖";
        text = sensitiveFilter.filter(text);
        System.out.println(text);

        text = "这里可以☆赌☆博☆,可以☆嫖☆娼☆,可以☆吸☆毒☆,可以☆开☆票☆,哈哈哈!";
        text = sensitiveFilter.filter(text);
        System.out.println(text);

        System.out.println( sensitiveFilter.filter("嫖123"));
    }
```



> 在检查用户的发表内容时，往往需要检查是否有html的<> 语句、敏感词，所有经常作用使用
>
> ```java
>         if (discussPost == null) {
>             throw new RuntimeException("数据为空");
>         }        
> 		//转义xml语言
>         String title = HtmlUtils.htmlEscape(discussPost.getTitle());
>         String content =HtmlUtils.htmlEscape(discussPost.getContent());
>         //过滤敏感词
>         discussPost.setTitle(sensitiveFilter.filter(title));
>         discussPost.setContent(sensitiveFilter.filter(content));
> 
> 		return discussPostMapper.insert(discussPost);
> ```
>
> 















## 统一异常处理(AOP)

> 就是`控制层的一个aop`

[参考](D:\workplace\JavaWeb_Video\MyNote\SpringMVC\SSM实例开发.md#简单实例)，可以说是没什么区别

- `controller/advice/ExceptionAdvice`

```java
//控制器的统一异常处理
@RestControllerAdvice(annotations = Controller.class)
public class ExceptionAdvice {

    private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);

    @ExceptionHandler({Exception.class})
    public Result handleException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException {
        logger.error("服务器发生异常: " + e.getMessage());
        for (StackTraceElement element : e.getStackTrace()) {
            logger.error(element.toString());
        }

        //请求的类型：XMLHttpRequest--异步请求，请求数据
        String xRequestedWith = request.getHeader("x-requested-with");
        if ("XMLHttpRequest".equals(xRequestedWith)) {
            return new Result(1, null, "服务器异常!");
        } else {
            response.sendRedirect(request.getContextPath() + "/error");
            return null;
        }
    }

}
```



- `HomeController`

  ```java
  //这里是手动导向错误页面，异常页面会自动有springBoot加载，不过要再error下
  @RequestMapping(path = "/error", method = RequestMethod.GET)
  public String getErrorPage() {
      //异常页面
      return "/error/500";
  }
  ```

> 1. 一般spring会自动加载error下的异常页面，假如访问异常就会跑到这里，不过这里使用统一异常处理手动导向错误页面
>
> 2. 由于这个项目使用了模板，所以
>
>    异步请求（请求数据） ————> XMLHttpRequest? ————> 返回json错误数据
>
>    同步请求（请求页面） ————> 返回错误页面



<img src="./assets/image-20230615232016888.png" alt="image-20230615232016888" style="zoom:50%;" />









## 统一记录日志

> 就是`service层的一个普通aop`，不像事务管理那样被封装起来

> 这个和上面的不同，上面的是记录一般情况下的日记信息，假如涉及到业务类型的日记、或者像自定义一些日志则没办法
>
> 这个偏向于 `系统需求` != `业务需求`
>
> 讲的怎么高级，其实就是使用aop记录是`哪些用户访问了业务层，干了什么事`，将这部分内容格式化一下存放到日志文件



- `aspect/ServiceLogAspect`

```java
@Component
@Aspect
public class ServiceLogAspect {

    private static final Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);

    @Pointcut("execution(* com.nowcoder.community.service.*.*(..))")
    public void pointcut() {

    }

    @Before("pointcut()")
    public void before(JoinPoint joinPoint) {
        // 用户[1.2.3.4],在[xxx],访问了[com.nowcoder.community.service.xxx()].
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        String ip = request.getRemoteHost();
        String now = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
        String target = joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName();
        logger.info(String.format("用户[%s],在[%s],访问了[%s].", ip, now, target));
    }

}
```

[参考](D:\workplace\JavaWeb_Video\MyNote\Spring\AOP.md#基于注解的AOP)











# 常量接口

# 文件输出流

